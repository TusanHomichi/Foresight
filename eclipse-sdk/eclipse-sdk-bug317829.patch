### Eclipse Workspace Patch 1.0
#P org.eclipse.jdt.core
Index: compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java,v
retrieving revision 1.61
diff -u -r1.61 DoStatement.java
--- compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java	12 Aug 2010 16:58:28 -0000	1.61
+++ compiler/org/eclipse/jdt/internal/compiler/ast/DoStatement.java	22 Aug 2010 05:33:14 -0000
@@ -112,7 +112,11 @@
 				actionInfo.addPotentialNullInfoFrom(
 				  condInfo.initsWhenTrue().unconditionalInits()));
 	}
-
+	if (loopingContext.hasEscapingExceptions()) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=321926
+		FlowInfo loopbackFlowInfo = flowInfo.copy();
+		loopbackFlowInfo.mergedWith(condInfo.initsWhenTrue().unconditionalCopy());
+		loopingContext.simulateThrowAfterLoopBack(loopbackFlowInfo);
+	}
 	// end of loop
 	FlowInfo mergedInfo = 
 		FlowInfo.mergedOptimizedBranches(
Index: compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java,v
retrieving revision 1.68
diff -u -r1.68 ForStatement.java
--- compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java	12 Aug 2010 16:58:28 -0000	1.68
+++ compiler/org/eclipse/jdt/internal/compiler/ast/ForStatement.java	22 Aug 2010 05:33:14 -0000
@@ -198,7 +198,13 @@
 			incrementContext.complainOnDeferredNullChecks(currentScope,
 				actionInfo);
 		}
-
+		if (loopingContext.hasEscapingExceptions()) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=321926
+			FlowInfo loopbackFlowInfo = flowInfo.copy();
+			if (this.continueLabel != null) {  // we do get to the bottom 
+				loopbackFlowInfo.mergedWith(actionInfo.unconditionalCopy());
+			}
+			loopingContext.simulateThrowAfterLoopBack(loopbackFlowInfo);
+		}
 		//end of loop
 		FlowInfo mergedInfo = FlowInfo.mergedOptimizedBranches(
 				(loopingContext.initsOnBreak.tagBits &
Index: compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java,v
retrieving revision 1.65
diff -u -r1.65 WhileStatement.java
--- compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java	12 Aug 2010 16:58:28 -0000	1.65
+++ compiler/org/eclipse/jdt/internal/compiler/ast/WhileStatement.java	22 Aug 2010 05:33:15 -0000
@@ -141,6 +141,13 @@
 						actionInfo.unconditionalInits()).
 					addInitializationsFrom(condInfo.initsWhenFalse());
 			}
+			if (loopingContext.hasEscapingExceptions()) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=321926
+				FlowInfo loopbackFlowInfo = flowInfo.copy();
+				if (this.continueLabel != null) {  // we do get to the bottom 
+					loopbackFlowInfo.mergedWith(actionInfo.unconditionalCopy());
+				}
+				loopingContext.simulateThrowAfterLoopBack(loopbackFlowInfo);
+			}
 		}
 
 		// end of loop
Index: compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java,v
retrieving revision 1.66
diff -u -r1.66 FlowContext.java
--- compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java	25 Feb 2010 15:27:01 -0000	1.66
+++ compiler/org/eclipse/jdt/internal/compiler/flow/FlowContext.java	22 Aug 2010 05:33:15 -0000
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
+import java.util.ArrayList;
 import org.eclipse.jdt.core.compiler.CharOperation;
 import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
@@ -92,6 +93,7 @@
 	// all related catch blocks are marked as reachable... instead of those only
 	// until the point where it is safely handled (Smarter - see comment at the end)
 	FlowContext traversedContext = this;
+	ArrayList abruptlyExitedLoops = null;
 	while (traversedContext != null) {
 		SubRoutineStatement sub;
 		if (((sub = traversedContext.subroutine()) != null) && sub.isSubRoutineEscaping()) {
@@ -115,6 +117,12 @@
 				    int state = caughtException == null
 				    	? Scope.EQUAL_OR_MORE_SPECIFIC /* any exception */
 				        : Scope.compareTypes(raisedException, caughtException);
+				    if (abruptlyExitedLoops != null && state != Scope.NOT_RELATED) {
+				    	for (int i = 0, abruptlyExitedLoopsCount = abruptlyExitedLoops.size(); i < abruptlyExitedLoopsCount; i++) {
+							LoopingFlowContext loop = (LoopingFlowContext) abruptlyExitedLoops.get(i);
+							loop.recordCatchContextOfEscapingException(exceptionContext, caughtException);
+						}
+					}
 					switch (state) {
 						case Scope.EQUAL_OR_MORE_SPECIFIC :
 							exceptionContext.recordHandlingException(
@@ -156,6 +164,11 @@
 				}
 				break; // not handled anywhere, thus jump to error handling
 			}
+		} else if (traversedContext instanceof LoopingFlowContext) {
+			if (abruptlyExitedLoops == null) {
+				abruptlyExitedLoops = new ArrayList(5);
+			}
+			abruptlyExitedLoops.add(traversedContext);
 		}
 
 		traversedContext.recordReturnFrom(flowInfo.unconditionalInits());
@@ -195,6 +208,7 @@
 		raisedCount);
 	FlowContext traversedContext = this;
 
+	ArrayList abruptlyExitedLoops = null;
 	while (traversedContext != null) {
 		SubRoutineStatement sub;
 		if (((sub = traversedContext.subroutine()) != null) && sub.isSubRoutineEscaping()) {
@@ -220,6 +234,12 @@
 						    int state = caughtException == null
 						    	? Scope.EQUAL_OR_MORE_SPECIFIC /* any exception */
 						        : Scope.compareTypes(raisedException, caughtException);
+						    if (abruptlyExitedLoops != null && state != Scope.NOT_RELATED) {
+						    	for (int i = 0, abruptlyExitedLoopsCount = abruptlyExitedLoops.size(); i < abruptlyExitedLoopsCount; i++) {
+									LoopingFlowContext loop = (LoopingFlowContext) abruptlyExitedLoops.get(i);
+									loop.recordCatchContextOfEscapingException(exceptionContext, caughtException);
+								}
+							}
 							switch (state) {
 								case Scope.EQUAL_OR_MORE_SPECIFIC :
 									exceptionContext.recordHandlingException(
@@ -282,6 +302,11 @@
 				}
 				break; // not handled anywhere, thus jump to error handling
 			}
+        } else if (traversedContext instanceof LoopingFlowContext) {
+			if (abruptlyExitedLoops == null) {
+				abruptlyExitedLoops = new ArrayList(5);
+			}
+			abruptlyExitedLoops.add(traversedContext);
 		}
 		if (remainingCount == 0)
 			return;
Index: compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java,v
retrieving revision 1.50
diff -u -r1.50 LoopingFlowContext.java
--- compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java	25 Feb 2010 15:27:00 -0000	1.50
+++ compiler/org/eclipse/jdt/internal/compiler/flow/LoopingFlowContext.java	22 Aug 2010 05:33:15 -0000
@@ -10,6 +10,7 @@
  *******************************************************************************/
 package org.eclipse.jdt.internal.compiler.flow;
 
+import java.util.ArrayList;
 import org.eclipse.jdt.internal.compiler.ast.ASTNode;
 import org.eclipse.jdt.internal.compiler.ast.Expression;
 import org.eclipse.jdt.internal.compiler.ast.Reference;
@@ -17,6 +18,7 @@
 import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
 import org.eclipse.jdt.internal.compiler.lookup.FieldBinding;
 import org.eclipse.jdt.internal.compiler.lookup.LocalVariableBinding;
+import org.eclipse.jdt.internal.compiler.lookup.ReferenceBinding;
 import org.eclipse.jdt.internal.compiler.lookup.Scope;
 import org.eclipse.jdt.internal.compiler.lookup.TypeIds;
 import org.eclipse.jdt.internal.compiler.lookup.VariableBinding;
@@ -45,6 +47,23 @@
 	int[] nullCheckTypes;
 	int nullCount;
 
+	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=321926
+	static private class EscapingExceptionCatchSite {
+		final ReferenceBinding caughtException;
+		final ExceptionHandlingFlowContext catchingContext;
+		public EscapingExceptionCatchSite(ExceptionHandlingFlowContext catchingContext,	ReferenceBinding caughtException) {
+			this.catchingContext = catchingContext;
+			this.caughtException = caughtException;
+		}
+		void simulateThrowAfterLoopBack(FlowInfo flowInfo) {
+			this.catchingContext.recordHandlingException(this.caughtException,
+					flowInfo.unconditionalInits(), null, // raised exception, irrelevant here
+					null, /* invocation site, irrelevant here */ true // we have no business altering the needed status.
+					);
+		}
+	}
+	private ArrayList escapingExceptionCatchSites = null;
+
 	Scope associatedScope;
 
 	public LoopingFlowContext(
@@ -608,4 +627,31 @@
 			}
 		}
 	}
+
+	/* Simulate a throw of an exception from inside a loop in its second or subsequent iteration.
+	   See https://bugs.eclipse.org/bugs/show_bug.cgi?id=321926
+	 */
+	public void simulateThrowAfterLoopBack(FlowInfo flowInfo) {
+		if (this.escapingExceptionCatchSites != null) {
+			for (int i = 0, exceptionCount = this.escapingExceptionCatchSites.size(); i < exceptionCount; i++) {
+				((EscapingExceptionCatchSite) this.escapingExceptionCatchSites.get(i)).simulateThrowAfterLoopBack(flowInfo);
+			}
+			this.escapingExceptionCatchSites = null; // don't care for it anymore.
+		}
+	}
+
+	/* Record the fact that some exception thrown by code within this loop
+	   is caught by an outer catch block. This is used to propagate data flow
+	   along the edge back to the next iteration. See simulateThrowAfterLoopBack
+	 */
+	public void recordCatchContextOfEscapingException(ExceptionHandlingFlowContext catchingContext,	ReferenceBinding caughtException) {
+		if (this.escapingExceptionCatchSites == null) {
+			this.escapingExceptionCatchSites = new ArrayList(5);
+		}
+		this.escapingExceptionCatchSites.add(new EscapingExceptionCatchSite(catchingContext, caughtException));
+	}
+
+	public boolean hasEscapingExceptions() {
+		return this.escapingExceptionCatchSites != null;
+	}
 }
#P org.eclipse.jdt.core.tests.compiler
Index: src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.jdt.core.tests.compiler/src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java,v
retrieving revision 1.98
diff -u -r1.98 NullReferenceTest.java
--- src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java	19 Aug 2010 10:38:43 -0000	1.98
+++ src/org/eclipse/jdt/core/tests/compiler/regression/NullReferenceTest.java	22 Aug 2010 05:33:22 -0000
@@ -12072,4 +12072,953 @@
 		"    24  return\n";
 	checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput);
 }
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=321926
+// To verify that a "redundant null check" warning is NOT elicited for a variable assigned non-null
+// in an infinite while loop inside a try catch block and that code generation shows no surprises.
+public void testBug321926a() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		while (true) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+// Test that dead code warning does show up.
+public void testBug321926b() {
+	this.runNegativeTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		while (true) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"       System.out.println(\"This is dead code\");\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+			"----------\n" + 
+			"1. ERROR in X.java (at line 15)\n" + 
+			"	System.out.println(\"This is dead code\");\n" + 
+			"	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n" + 
+			"Unreachable code\n" + 
+			"----------\n");
+}
+// Check nullness in catch block, finally block and downstream code.
+public void testBug321926c() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		while (true) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler buggy\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+			"	 } finally {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler buggy\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+            "    }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good Compiler good Compiler good");
+}
+// Various nested loops.
+public void testBug321926d() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       while (true) {\n" +
+			"           for(;;) { \n" +
+			"				while (true) {\n" +
+			"					if (i == 0){\n" +
+			"						someVariable = \"not null\";\n" +
+			"						i++;\n" +
+			"					}\n" +
+			"					else\n" +
+			"						throw new IOException();\n" +
+			"				}\n" +
+			"			}\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler buggy\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+			"	 } finally {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler buggy\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+            "    }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good Compiler good Compiler good");
+}
+// Test widening catch. 
+public void testBug321926e() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		while (true) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (Exception e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+// Tested nested try blocks.
+public void testBug321926f() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"    public static void main(String[] args) {\n" +
+			"        String someVariable = null;\n" +
+			"        int i = 0;\n" +
+			"        try {\n" +
+			"        	while (true) {\n" +
+			"        		if (i != 0) {\n" +
+			"        			try {\n" +
+			"        				throw new IOException();\n" +
+			"        			} catch (IOException e) {\n" +
+			"        				if (someVariable == null) {\n" +
+			"        					System.out.println(\"The compiler is buggy\");\n" +
+			"        				} else {\n" +
+			"        					System.out.print(\"Compiler good \");\n" +
+			"        				}\n" +
+			"        				throw e;\n" +
+			"        			}\n" +
+			"        		} else {\n" +
+			"        			someVariable = \"not null\";\n" +
+			"        			i++;\n" +
+			"        		}\n" +
+			"        	}\n" +
+			"        } catch (Exception e) {\n" +
+			"            // having broken from loop, continue on\n" +
+			"        }\n" +
+			"        if (someVariable == null) {\n" +
+			"            System.out.println(\"The compiler is buggy\");\n" +
+			"        } else {\n" +
+			"            System.out.println(\"Compiler good\");\n" +
+			"        }\n" +
+			"    }\n" +
+			"}\n"},
+		"Compiler good Compiler good");
+}
+// test for loop
+public void testBug321926g() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		for (int j = 0; true; j++) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+// test do while loop
+public void testBug321926h() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		do {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		} while(true);\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+// test with while (true) with a break inside. was working already.
+public void testBug321926i() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		while (true) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"               break;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+// Test with non-explicit throws, i.e call method which throws rather than an inline throw statement. 
+public void testBug321926j() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		while (true) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				invokeSomeMethod();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"  public static void invokeSomeMethod() throws IOException {\n" +
+			"      throw new IOException();\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+// Variation with nested loops
+public void testBug321926k() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       while (true) {\n" +
+			"       	try {\n" +
+			"				while (true) {\n" +
+			"					if (i == 0){\n" +
+			"						someVariable = \"not null\";\n" +
+			"						i++;\n" +
+			"					}\n" +
+			"					else\n" +
+			"						throw new IOException();\n" +
+			"				}\n" +
+			"       	} catch (IOException e) {\n" +
+			"           }\n" +
+			"	 		if (someVariable == null) {\n" +
+			"    			System.out.println(\"Compiler buggy\");\n" +
+			"	 		} else {\n" +
+			"				System.out.print(\"Compiler good \");\n" +
+			"	 		}\n" +
+			"           throw new IOException();\n" +
+			"       }\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good Compiler good");
+}
+// variation with nested loops.
+public void testBug321926l() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       while (true) {\n" +
+			"           someVariable = null;\n"+
+			"       	try {\n" +
+			"				while (true) {\n" +
+			"					if (i == 0){\n" +
+			"						someVariable = \"not null\";\n" +
+			"						i++;\n" +
+			"					}\n" +
+			"					else\n" +
+			"						throw new IOException();\n" +
+			"				}\n" +
+			"       	} catch (IOException e) {\n" +
+			"           }\n" +
+			"	 		if (someVariable == null) {\n" +
+			"    			System.out.println(\"Compiler buggy\");\n" +
+			"	 		} else {\n" +
+			"				System.out.print(\"Compiler good \");\n" +
+			"	 		}\n" +
+			"           throw new IOException();\n" +
+			"       }\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good Compiler good");
+}
+public void testBug321926m() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"		while (true) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"           if (true) {\n" +
+			"               break;\n" +
+			"           }\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+public void testBug321926n() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		while (true) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+public void testBug321926o() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		for(;;) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+public void testBug321926p() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		do {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		} while (true);\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good");
+}
+public void testBug321926q() {
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.WARNING);
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		do {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		} while ((someVariable = \"not null\") != null);\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good", null, true, null, options, null);
+}
+public void testBug321926r() {
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.IGNORE);
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       while ((someVariable = \"not null\") != null) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler buggy\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good", null, true, null, options, null
+		);
+}
+public void testBug321926s() {
+	Map options = getCompilerOptions();
+	options.put(CompilerOptions.OPTION_ReportRedundantNullCheck, CompilerOptions.IGNORE);
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \" not null\";\n" +
+			"       while ((someVariable = null) != null) {\n" +
+			"			if (i == 0){\n" +
+			"				someVariable = \"not null\";\n" +
+			"				i++;\n" +
+			"			}\n" +
+			"			else\n" +
+			"				throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"		// broken from loop, continue on\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler good\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler buggy\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+		"Compiler good", null, true, null, options, null
+		);
+}
+public void testBug321926t() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"	public static void main(String s[]) {\n" +
+			"		String file = \"non null\";\n" +
+			"		int i = 0;\n" +
+			"       try {\n" +
+			"			while (true) {\n" +
+			"			    if (i == 0) {\n" +
+			"					file = null;\n" +
+			"                   i++;\n"+
+			"               }\n" +
+			"               else \n" +
+			"               	throw new IOException();\n" +
+			"			}\n" +
+			"       } catch (IOException e) {\n" +
+			"       }\n" +
+			"		if (file == null)\n" +
+			"		    System.out.println(\"Compiler good\");\n" +
+			"       else \n" +
+			"		    System.out.println(\"Compiler bad\");\n" +
+			"	}\n" +
+			"}\n"},
+		"Compiler good");
+}
+public void testBug321926u() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"	public static void main(String s[]) {\n" +
+			"		String file = \"non null\";\n" +
+			"		int i = 0;\n" +
+			"       try {\n" +
+			"			while (true) {\n" +
+			"			    if (i == 0) {\n" +
+			"					file = null;\n" +
+			"                   i++;\n"+
+			"               }\n" +
+			"               else {\n" +
+			"                   file = null;\n" +
+			"               	throw new IOException();\n" +
+			"               }\n" +
+			"			}\n" +
+			"       } catch (IOException e) {\n" +
+			"       }\n" +
+			"		if (file == null)\n" +
+			"		    System.out.println(\"Compiler good\");\n" +
+			"       else \n" +
+			"		    System.out.println(\"Compiler bad\");\n" +
+			"	}\n" +
+			"}\n"},
+		"Compiler good");
+}
+public void testBug321926v() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"	public static void main(String s[]) {\n" +
+			"		String file = null;\n" +
+			"		int i = 0;\n" +
+			"       try {\n" +
+			"			while (true) {\n" +
+			"			    if (i == 0) {\n" +
+			"					file = \"non null\";\n" +
+			"                   i++;\n"+
+			"               }\n" +
+			"               else {\n" +
+			"                   file = \"non null\";\n" +
+			"               	throw new IOException();\n" +
+			"               }\n" +
+			"			}\n" +
+			"       } catch (IOException e) {\n" +
+			"       }\n" +
+			"		if (file == null)\n" +
+			"		    System.out.println(\"Compiler bad\");\n" +
+			"       else \n" +
+			"		    System.out.println(\"Compiler good\");\n" +
+			"	}\n" +
+			"}\n"},
+		"Compiler good");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317829
+public void testBug317829a() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		while (true) {\n" +
+			"			throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler bad\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler bad\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+			"Compiler good Compiler good");
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=317829
+public void testBug317829b() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		while (true) {\n" +
+			"			someMethod();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler bad\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler bad\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"  public static void someMethod() throws IOException {\n" +
+			"      throw new IOException();\n" +
+			"  }\n" +
+			"}"},
+			"Compiler good Compiler good");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317829
+public void testBug317829c() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		for (;;) {\n" +
+			"			throw new IOException();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler bad\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler bad\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+			"Compiler good Compiler good");
+}
+//https://bugs.eclipse.org/bugs/show_bug.cgi?id=317829
+public void testBug317829d() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		for(;;) {\n" +
+			"			someMethod();\n" +
+			"		}\n" +
+			"	 } catch (IOException e) {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler bad\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler bad\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"  public static void someMethod() throws IOException {\n" +
+			"      throw new IOException();\n" +
+			"  }\n" +
+			"}"},
+			"Compiler good Compiler good");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317829
+public void testBug317829e() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		do {\n" +
+			"			throw new IOException();\n" +
+			"		} while (true);\n" +
+			"	 } catch (IOException e) {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler bad\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler bad\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"}"},
+			"Compiler good Compiler good");
+}
+// https://bugs.eclipse.org/bugs/show_bug.cgi?id=317829
+public void testBug317829f() {
+	this.runConformTest(
+		new String[] {
+			"X.java",
+			"import java.io.IOException;\n" +
+			"public class X {\n" +
+			"  public static void main(String[] args) {\n" +
+			"	 String someVariable = null;\n" +
+			"	 int i = 0;\n" +
+			"	 try {\n" +
+			"       someVariable = \"not null\";\n" +
+			"		do {\n" +
+			"			someMethod();\n" +
+			"		} while (true);\n" +
+			"	 } catch (IOException e) {\n" +
+			"	 	if (someVariable == null) {\n" +
+			"    		System.out.println(\"Compiler bad\");\n" +
+			"	 	} else {\n" +
+			"			System.out.print(\"Compiler good \");\n" +
+			"	 	}\n" +
+			"	 }\n" +
+			"	 if (someVariable == null) {\n" +
+			"    	System.out.println(\"Compiler bad\");\n" +
+			"	 } else {\n" +
+			"		System.out.println(\"Compiler good\");\n" +
+			"	 }\n" +
+			"  }\n" +
+			"  public static void someMethod() throws IOException {\n" +
+			"      throw new IOException();\n" +
+			"  }\n" +
+			"}"},
+			"Compiler good Compiler good");
+}
 }
\ No newline at end of file
